package gov.ca.dir.acct.cars.adf.service.appmodule;

import gov.ca.dir.acct.cars.adf.common.code.ApplicationModuleImpl;

import gov.ca.dir.acct.cars.adf.service.appmodule.common.CarsBCUtilityServicesAM;

import java.sql.CallableStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.text.SimpleDateFormat;
import oracle.jbo.JboException;
import oracle.jbo.domain.Number;
import oracle.jbo.server.DBTransaction;
import oracle.jbo.server.SequenceImpl;

// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Tue Sep 03 13:22:49 PDT 2013
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class CarsBCUtilityServicesAMImpl extends ApplicationModuleImpl implements CarsBCUtilityServicesAM {
    
    private static final String FUNC_GET_RECLASSIFY_REF_DOC = "begin ? := FUNC_GET_RECLASSIFY_REF_DOC(?); end;";
    private static final String FUNC_GET_CONTINGENT_REF_DOC = "begin ? := FUNC_GET_CONTINGENT_REF_DOC(?); end;";
    

    /**
     * This is the default constructor (do not remove).
     */
    public CarsBCUtilityServicesAMImpl() {
    }

    /**
     * Get next Event ID sequence number.
     * @return Number
     */
    public oracle.jbo.domain.Number getEventIDSequence() {
        return (new SequenceImpl("EVENT_ID_SEQ",
                                 getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next AR Status ID sequence number.
     * @return Number
     */
    public oracle.jbo.domain.Number getARStatusIDSequence() {
        return (new SequenceImpl("AR_STATUS_ID_SEQ",
                                 getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next Party ID sequence number.
     * @return Number
     */
    public oracle.jbo.domain.Number getPartyIDSequence() {
        return (new SequenceImpl("PARTY_ID_SEQ",
                                 getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next Participant Role ID sequence number.
     * @return Number
     */
    public oracle.jbo.domain.Number getParticipantRoleIdSequence() {
        return (new SequenceImpl("PARTICIPANT_ROLE_ID_SEQ",
                                 getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next Contact Method ID sequence number.
     * @return Number
     */
    public oracle.jbo.domain.Number getContactMethodIdSequence() {
        return (new SequenceImpl("CONTACT_METHOD_ID_SEQ",
                                 getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next Address ID sequence number.
     * @return Number
     */
    public oracle.jbo.domain.Number getAddressIdSequence() {
        return (new SequenceImpl("ADDRESS_ID_SEQ",
                                 getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next Accounting Transaction ID sequence number.
     * @return Number
     */
    public oracle.jbo.domain.Number getAcctgTransactionIdSequence() {
        return (new SequenceImpl("ACCTG_TRANSACTION_ID_SEQ",
                                 getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next Accounting Entry ID sequence number.
     * @return Number
     */
    public oracle.jbo.domain.Number getAcctgEntryIdSequence() {
        return (new SequenceImpl("ACCTG_ENTRY_ID_SEQ",
                                 getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next Note ID sequence number.
     * @return Number
     */
    public oracle.jbo.domain.Number getNoteIdSequence() {
        return (new SequenceImpl("NOTE_ID_SEQ",
                                 getDBTransaction())).getSequenceNumber();
    }


    /**
     * Executes PL/SQL Store Functions. See Oracle documentation.
     * @param sqlReturnType - the Type of the return value of the function
     * @param stmt - the name of the Function to be executed
     * @param bindVars - array of variables to be bound to the Function 
     *              input variables
     * @return Object 
     */
    protected Object callStoredFunction(int sqlReturnType, String stmt,
                                        Object[] bindVars) {
        CallableStatement st = null;
        try {
            // 1. Create a JDBC CallabledStatement
            st = getDBTransaction().createCallableStatement("begin ? := " + stmt + ";end;", 0);
            // 2. Register the first bind variable for the return value
            st.registerOutParameter(1, sqlReturnType);
            if (bindVars != null) {
                // 3. Loop over values for the bind variables passed in, if any
                for (int z = 0; z < bindVars.length; z++) {
                    // 4. Set the value of user-supplied bind vars in the stmt
                    st.setObject(z + 2, bindVars[z]);
                }
            }
            // 5. Set the value of user-supplied bind vars in the stmt
            st.executeUpdate();
            // 6. Return the value of the first bind variable
            return st.getObject(1);
        } catch (SQLException e) {
            throw new JboException(e);
        } finally {
            if (st != null) {
                try {
                    // 7. Close the statement
                    st.close();
                } catch (SQLException e) {
                }
            }
        }
    }
    
    /**
     * Executes FUNC_IS_REVERSED pl/sql function that checks if a given event 
     * was reversed. If nonzero value is returned then event in not reversed.
     * @param currentDocumentNumber   String
     * @return Number 
     */
    public oracle.jbo.domain.Number isEventReversed(String currentDocumentNumber) {
        synchronized (this) {
            try {
                return new oracle.jbo.domain.Number(callStoredFunction(Types.INTEGER,
                    "FUNC_IS_REVERSED(?)",
                    new Object[] { currentDocumentNumber }));
            } catch (SQLException e) {
            }
            return null;
        }
    }


    /**
     * Executes FUNC_CHECK_CHILD_EXIST pl/sql function that checks if a given event 
     * have children. 1 is returned if children exist, 0 otherwise.
     * @param currentDocumentNumber     String
     * @return Number 
     */
    public oracle.jbo.domain.Number isChildrenExist(String currentDocumentNumber) {
        synchronized (this) {
            try {
                return new oracle.jbo.domain.Number(callStoredFunction(Types.INTEGER,
                    "FUNC_CHECK_CHILD_EXIST(?)",
                    new Object[] { currentDocumentNumber }));
            } catch (SQLException e) {
            }
            return null;
        }
    }
    
    
    /**
     * determine whether the given Reference Document is event AR Others or belonged to 
     * 2 years prior from current fiscal year or not.
     * 
     * @param ReferenceDocument    String
     * @return  1 if the given Reference Document is belonged to AR Others or
     * more than 2 years from the current fiscal year. Otherwise, return 0.
     */
    public oracle.jbo.domain.Number is2YearsPrior(String ReferenceDocument) {
        synchronized (this) {
            try {
                return new oracle.jbo.domain.Number(callStoredFunction(Types.INTEGER,
                    "FUNC_IS_2YEARS_PRIOR(?)",
                    new Object[] { ReferenceDocument }));
            } catch (SQLException e) {
            }
            
            return null;  
        }
    }//is2YearsPrior()
    
    /**
     * get current balance for given Reference Document Number.
     * 
     * @param ReferenceDocument    String
     * @return    Number
     */
    public oracle.jbo.domain.Number getCurrentBalance(String ReferenceDocument) {
        synchronized (this) {
            try {
                return new oracle.jbo.domain.Number(callStoredFunction(Types.DOUBLE,
                    "FUNC_GET_GL_BALANCE(?,?)",
                    new Object[] { ReferenceDocument, "1313" }));
            } catch (SQLException e) {
            }
            
            return null; 
        }            
    }//getCurrentBalance()
    
    /**
     * Returns current document number of the AR-Other event given the root document number
     * of the original AR setup event
     * 
     * @param rootDocument    String
     * @return currentDocumentNumnber String
     * 
     */
    public String findAROtherReferenceDocumentWithParams(String rootDocument) {

        if (rootDocument == null || rootDocument.isEmpty()) {
             new JboException("Root Document cannot be empty");
        }
        
        synchronized (this) {
            String currentDocNumber = null;
            CallableStatement callableStm = null;
            DBTransaction dbTransaction = getDBTransaction();  
            
            //call FUNC_GET_FISCAL_PERIOD_ID to get Fiscal period Id for given Root Document
            try {
                callableStm = dbTransaction.createCallableStatement(FUNC_GET_RECLASSIFY_REF_DOC, dbTransaction.DEFAULT);
                callableStm.setObject(2, rootDocument);
                callableStm.registerOutParameter(1, Types.VARCHAR);
                callableStm.execute();
                currentDocNumber = (String)callableStm.getObject(1);
            } catch (SQLException sqlEx) {
                new JboException(sqlEx);
            } finally {
                if (callableStm != null) {
                    try {
                        callableStm.close();
                    } catch (SQLException sqlEx1) {
                        new JboException(sqlEx1);
                    }
                }
            }
        
            return currentDocNumber;
        }
    }//findFiscalPeriodIdWithParams()

    /**
    * determine whether the givent Reference Document has Fiscal Year belonged to 
    * 2 years prior from current fiscal year and event 515 (Reclassifiation) doesn't exist.
    * 
    * @param ReferenceDocument    String
    * @return  1 if need Reclassification process. Otherwise, return 0.
    */
    public oracle.jbo.domain.Number isReclassNeeded(String ReferenceDocument) {
        synchronized (this) {
            try {
                return new oracle.jbo.domain.Number(callStoredFunction(Types.INTEGER,
                    "FUNC_IS_RECLASS_NEEDED(?)",
                    new Object[] { ReferenceDocument }));
            } catch (SQLException e) {
            }
           
            return null; 
        }
    }//isReclassNeeded()
    
    /**
     * find AR Others Contingent Reference Document for given Reference Document
     * 
     * @param referenceDocument    String
     * @return  Contingent AR Others Current Document If there eixsted Reclass and
     *          Contingent AR Others.
     *          Reclass current document If there existed reclass only
     *          Given Reference Document if the reclass doesn't exist.
     */
    public String findAROthersContingentRefDoc(String referenceDocument) {
        if (referenceDocument == null || referenceDocument.isEmpty()) {
             new JboException("Reference Document cannot be empty");
        }

        synchronized (this) {
            String currentDocNumber = null;
            CallableStatement callableStm = null;
            DBTransaction dbTransaction = getDBTransaction();  
            
            //call FUNC_GET_FISCAL_PERIOD_ID to get Fiscal period Id for given Root Document
            try {
                callableStm = dbTransaction.createCallableStatement(FUNC_GET_CONTINGENT_REF_DOC, dbTransaction.DEFAULT);
                callableStm.setObject(2, referenceDocument);
                callableStm.registerOutParameter(1, Types.VARCHAR);
                callableStm.execute();
                currentDocNumber = (String)callableStm.getObject(1);
            } catch (SQLException sqlEx) {
                new JboException(sqlEx);
            } finally {
                if (callableStm != null) {
                    try {
                        callableStm.close();
                    } catch (SQLException sqlEx1) {
                        new JboException(sqlEx1);
                    }
                }
            }
            
            return currentDocNumber; 
        }
    }//findAROthersContingentRefDoc()
    
    /**
     * traversal up from given Reference Document to determine whether prior 2 years
     * event such as 015, 515, or 516 existed or not. Return 
     * 
     * @param ReferenceDocument   String
     * @return 1 if the parents of given Reference Document are 015, 515, 0r 516.
     *         Otherwise, return 0.
     */
    public Number isAROthersRefDocExisted(String ReferenceDocument) {
        synchronized (this) {
            try {
                return new oracle.jbo.domain.Number(callStoredFunction(Types.INTEGER,
                    "FUNC_IS_AR_OTHERS_EXISTED(?)",
                    new Object[] { ReferenceDocument }));
            } catch (SQLException e) {
            }
            
            return null;  
        }
    }//isAROthersRefDocExisted()
    
    /**
     * check whether Reclass Event or Decision After Reclass Event existd or not 
     * for given Reference Document, Event Date, and event Type Code in order to 
     * detect Appeal Decision events.
     * 
     * @param     ReferenceDocument    String
     * @param     eventDateStr         String
     * @param     eventTypeCode        String
     * @return    1 if there existed either Reclass Event or Decision After Reclass Event
     *            Otherwise, return 0
     */
    public Number isDecisionAfterReclassExisted(String ReferenceDocument, 
            String eventDateStr, String eventTypeCode) {
        synchronized (this) {
            try {
                //date from payload has format yyyy-mm-ddT00:00:00-08:00
                String dateOnly = eventDateStr.substring(0, eventDateStr.indexOf("T"));
                SimpleDateFormat  df =  new SimpleDateFormat("yyyy-MM-dd");
                java.util.Date eventDate = df.parse(dateOnly);
                //change date format to mmddyyyy in order to match with the event date format in database
                SimpleDateFormat  df2 =  new SimpleDateFormat("MM-dd-yyyy"); 
                String date = df2.format(eventDate);
                java.util.Date eventDate2 = df2.parse(date);
                //use java sql date for DATE type in database FUNCTION
                java.sql.Date sqlEventDate = new java.sql.Date(eventDate2.getTime());
    
                return new oracle.jbo.domain.Number(callStoredFunction(Types.INTEGER,
                    "FUNC_DEC_AFTER_RECLASS_EXISTED(?, ?, ?)",
                    new Object[] { ReferenceDocument,  sqlEventDate, eventTypeCode}));
            } catch (Throwable e) {
                e.printStackTrace();
            }
            
            return null; 
        }
    }//isDecisionAfterReclassExisted()    
}
